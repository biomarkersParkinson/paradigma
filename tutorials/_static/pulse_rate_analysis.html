<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pulse rate analysis &mdash; paradigma  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=a31c8b26" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=a31c8b26" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            paradigma
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/sensor_requirements.html">Sensor Data Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/supported_devices.html">Supported Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/config.html">Configuration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/coordinate_system.html">Coordinate System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">paradigma</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Pulse rate analysis</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/tutorials/_static/pulse_rate_analysis.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pulse-rate-analysis">
<h1>Pulse rate analysis<a class="headerlink" href="#pulse-rate-analysis" title="Link to this heading"></a></h1>
<p>This tutorial shows how to extract pulse rate estimates using photoplethysmography (PPG) data and accelerometer data. The pipeline consists of a stepwise approach to determine signal quality, assessing both PPG morphology and accounting for periodic artifacts using the accelerometer. The usage of accelerometer is optional but is recommended to specifically account for periodic motion artifacts. Based on the signal quality, we extract high-quality segments and estimate the pulse rate for every 2 s using the smoothed pseudo Wigner-Ville Distribution.</p>
<p>In this tutorial, we use two days of data from a participant of the Personalized Parkinson Project to demonstrate the functionalities. Since <code class="docutils literal notranslate"><span class="pre">ParaDigMa</span></code> expects contiguous time series, the collected data was stored in two segments each with contiguous timestamps. Per segment, we load the data and perform the following steps:</p>
<ol class="arabic simple">
<li><p>Preprocess the time series data</p></li>
<li><p>Extract signal quality features</p></li>
<li><p>Signal quality classification</p></li>
<li><p>Pulse rate estimation</p></li>
</ol>
<p>We then combine the output of the different segments for the final step:</p>
<ol class="arabic simple" start="5">
<li><p>Pulse rate aggregation</p></li>
</ol>
<section id="import-required-modules">
<h2>Import required modules<a class="headerlink" href="#import-required-modules" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">importlib.resources</span><span class="w"> </span><span class="kn">import</span> <span class="n">files</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsdf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.classification</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassifierPackage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">IMUConfig</span><span class="p">,</span> <span class="n">PPGConfig</span><span class="p">,</span> <span class="n">PulseRateConfig</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataColumns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.pipelines.pulse_rate_pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">aggregate_pulse_rate</span><span class="p">,</span>
    <span class="n">estimate_pulse_rate</span><span class="p">,</span>
    <span class="n">extract_signal_quality_features</span><span class="p">,</span>
    <span class="n">signal_quality_classification</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_ppg_data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_tsdf_dataframe</span><span class="p">,</span> <span class="n">write_df_data</span>
</pre></div>
</div>
</section>
<section id="load-data">
<h2>Load data<a class="headerlink" href="#load-data" title="Link to this heading"></a></h2>
<p>This pipeline requires PPG data and can be enhanced with accelerometer data (optional). Here, we start by loading a single contiguous time series (segment), for which we continue running steps 1-4. Below we show how to run these steps for multiple segments. The channel <code class="docutils literal notranslate"><span class="pre">green</span></code> represents the values obtained with PPG using green light.</p>
<p>In this example we use the internally developed <code class="docutils literal notranslate"><span class="pre">TSDF</span></code> (<a class="reference external" href="https://biomarkersparkinson.github.io/tsdf/">documentation</a>) to load and store data [<a class="reference external" href="https://arxiv.org/abs/2211.11294">1</a>]. However, we are aware that there are other common data formats. For example, the following functions can be used depending on the file extension of the data:</p>
<ul class="simple">
<li><p><em>.csv</em>: <code class="docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code> (<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">documentation</a>)</p></li>
<li><p><em>.json</em>: <code class="docutils literal notranslate"><span class="pre">json.load()</span></code> (<a class="reference external" href="https://docs.python.org/3/library/json.html#json.load">documentation</a>)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the path to where the prepared data is saved and load the data.</span>
<span class="c1"># Note: the test data is stored in TSDF, but you can load your data in your own way</span>
<span class="n">path_to_prepared_data</span> <span class="o">=</span>  <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;../../example_data/verily&#39;</span><span class="p">)</span>

<span class="n">ppg_prefix</span> <span class="o">=</span> <span class="s1">&#39;ppg&#39;</span>
<span class="n">imu_prefix</span> <span class="o">=</span> <span class="s1">&#39;imu&#39;</span>

<span class="n">segment_nr</span> <span class="o">=</span> <span class="s1">&#39;0001&#39;</span>

<span class="n">df_ppg</span><span class="p">,</span> <span class="n">metadata_time_ppg</span><span class="p">,</span> <span class="n">metadata_values_ppg</span> <span class="o">=</span> <span class="n">load_tsdf_dataframe</span><span class="p">(</span>
    <span class="n">path_to_data</span><span class="o">=</span><span class="n">path_to_prepared_data</span> <span class="o">/</span> <span class="n">ppg_prefix</span><span class="p">,</span>
    <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;PPG_segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="c1"># Only relevant if you have IMU data available</span>
<span class="n">df_imu</span><span class="p">,</span> <span class="n">metadata_time_imu</span><span class="p">,</span> <span class="n">metadata_values_imu</span> <span class="o">=</span> <span class="n">load_tsdf_dataframe</span><span class="p">(</span>
    <span class="n">path_to_data</span><span class="o">=</span><span class="n">path_to_prepared_data</span> <span class="o">/</span> <span class="n">imu_prefix</span><span class="p">,</span>
    <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;IMU_segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="n">time_col</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="n">acc_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;accelerometer_x&#39;</span><span class="p">,</span> <span class="s1">&#39;accelerometer_y&#39;</span><span class="p">,</span> <span class="s1">&#39;accelerometer_z&#39;</span><span class="p">]</span>
<span class="n">df_acc</span> <span class="o">=</span> <span class="n">df_imu</span><span class="p">[</span><span class="n">time_col</span> <span class="o">+</span> <span class="n">acc_cols</span><span class="p">]</span>

<span class="n">display</span><span class="p">(</span><span class="n">df_ppg</span><span class="p">,</span> <span class="n">df_acc</span><span class="p">)</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>green</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00000</td>
      <td>262316</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.03340</td>
      <td>262320</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.06680</td>
      <td>262446</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.10020</td>
      <td>262770</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.13360</td>
      <td>262623</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1029370</th>
      <td>34339.49720</td>
      <td>1049632</td>
    </tr>
    <tr>
      <th>1029371</th>
      <td>34339.53056</td>
      <td>1049632</td>
    </tr>
    <tr>
      <th>1029372</th>
      <td>34339.56392</td>
      <td>1049632</td>
    </tr>
    <tr>
      <th>1029373</th>
      <td>34339.59728</td>
      <td>1049632</td>
    </tr>
    <tr>
      <th>1029374</th>
      <td>34339.63064</td>
      <td>1020788</td>
    </tr>
  </tbody>
</table>
<p>1029375 rows × 2 columns</p>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>accelerometer_x</th>
      <th>accelerometer_y</th>
      <th>accelerometer_z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000000</td>
      <td>-0.474641</td>
      <td>-0.379426</td>
      <td>0.770335</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.009933</td>
      <td>-0.472727</td>
      <td>-0.378947</td>
      <td>0.765072</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.019867</td>
      <td>-0.471770</td>
      <td>-0.375598</td>
      <td>0.766986</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.029800</td>
      <td>-0.472727</td>
      <td>-0.375598</td>
      <td>0.770335</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.039733</td>
      <td>-0.475120</td>
      <td>-0.379426</td>
      <td>0.772249</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>3455326</th>
      <td>34339.561333</td>
      <td>-0.257895</td>
      <td>-0.319139</td>
      <td>-0.761244</td>
    </tr>
    <tr>
      <th>3455327</th>
      <td>34339.571267</td>
      <td>-0.555502</td>
      <td>-0.153110</td>
      <td>-0.671292</td>
    </tr>
    <tr>
      <th>3455328</th>
      <td>34339.581200</td>
      <td>-0.286124</td>
      <td>-0.263636</td>
      <td>-0.981340</td>
    </tr>
    <tr>
      <th>3455329</th>
      <td>34339.591133</td>
      <td>-0.232536</td>
      <td>-0.161722</td>
      <td>-0.832536</td>
    </tr>
    <tr>
      <th>3455330</th>
      <td>34339.601067</td>
      <td>0.180383</td>
      <td>-0.368421</td>
      <td>-1.525837</td>
    </tr>
  </tbody>
</table>
<p>3455331 rows × 4 columns</p>
</div>
</section>
<section id="step-1-preprocess-data">
<h2>Step 1: Preprocess data<a class="headerlink" href="#step-1-preprocess-data" title="Link to this heading"></a></h2>
<p>The first step after loading the data is preprocessing using the <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/preprocessing/index.html#paradigma.preprocessing.preprocess_ppg_data">preprocess_ppg_data</a>. This begins by isolating segments containing both PPG and IMU data, discarding portions where one modality (e.g., PPG) extends beyond the other, such as when the PPG recording is longer than the accelerometer data. This functionality requires the starting times (<code class="docutils literal notranslate"><span class="pre">metadata_time_ppg.start_iso8601</span></code> and <code class="docutils literal notranslate"><span class="pre">metadata_time_imu.start_iso8601</span></code>) in iso8601 format as inputs. After this step, the preprocess_ppg_data function resamples the PPG and accelerometer data to uniformly distributed timestamps, addressing the fixed but non-uniform sampling rates of the sensors. If the difference between timestamps is larger than a specified tolerance (<code class="docutils literal notranslate"><span class="pre">config.tolerance</span></code>, in seconds), it will return an error that the timestamps are not contiguous.  If you still want to process the data in this case, you can create segments from discontiguous samples using the function <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/segmenting/index.html#paradigma.segmenting.create_segments"><code class="docutils literal notranslate"><span class="pre">create_segments</span></code></a> and analyze these segments consecutively as shown in here. After resampling, a bandpass Butterworth filter (4th-order, bandpass frequencies: 0.4–3.5 Hz) is applied to the PPG signal, while a high-pass Butterworth filter (4th-order, cut-off frequency: 0.2 Hz) is applied to the accelerometer data.</p>
<p>Note: the printed shapes are (rows, columns) with each row corresponding to a single data point and each column representing a data column (e.g.time). The number of rows of the overlapping segments of PPG and accelerometer are not the same due to sampling differences (other sensors and possibly other sampling frequencies).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set column names: replace DataColumn.* with your actual column names.</span>
<span class="c1"># It is only necessary to set the columns that are present in your data, and</span>
<span class="c1"># only if they differ from the default names defined in DataColumns.</span>
<span class="n">imu_column_mapping</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;TIME&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">TIME</span><span class="p">,</span>
    <span class="s1">&#39;ACCELEROMETER_X&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">ACCELEROMETER_X</span><span class="p">,</span>
    <span class="s1">&#39;ACCELEROMETER_Y&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">ACCELEROMETER_Y</span><span class="p">,</span>
    <span class="s1">&#39;ACCELEROMETER_Z&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">ACCELEROMETER_Z</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">ppg_column_mapping</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;TIME&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">TIME</span><span class="p">,</span>
    <span class="s1">&#39;PPG&#39;</span><span class="p">:</span> <span class="n">DataColumns</span><span class="o">.</span><span class="n">PPG</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">ppg_config</span> <span class="o">=</span> <span class="n">PPGConfig</span><span class="p">(</span><span class="n">column_mapping</span><span class="o">=</span><span class="n">ppg_column_mapping</span><span class="p">)</span>
<span class="n">imu_config</span> <span class="o">=</span> <span class="n">IMUConfig</span><span class="p">(</span><span class="n">column_mapping</span><span class="o">=</span><span class="n">imu_column_mapping</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;The tolerance for checking contiguous timestamps is set to &quot;</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ppg_config</span><span class="o">.</span><span class="n">tolerance</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds for PPG data and &quot;</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">imu_config</span><span class="o">.</span><span class="n">tolerance</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds for accelerometer data.&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Original data shapes:</span><span class="se">\n</span><span class="s2">- PPG data: </span><span class="si">{</span><span class="n">df_ppg</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;- Accelerometer data: </span><span class="si">{</span><span class="n">df_imu</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="p">)</span>
<span class="n">df_ppg_proc</span><span class="p">,</span> <span class="n">df_acc_proc</span> <span class="o">=</span> <span class="n">preprocess_ppg_data</span><span class="p">(</span>
    <span class="n">df_ppg</span><span class="o">=</span><span class="n">df_ppg</span><span class="p">,</span>
    <span class="n">ppg_config</span><span class="o">=</span><span class="n">ppg_config</span><span class="p">,</span>
    <span class="n">start_time_ppg</span><span class="o">=</span><span class="n">metadata_time_ppg</span><span class="o">.</span><span class="n">start_iso8601</span><span class="p">,</span>  <span class="c1"># Optional</span>
    <span class="n">df_acc</span><span class="o">=</span><span class="n">df_acc</span><span class="p">,</span>  <span class="c1"># Optional</span>
    <span class="n">imu_config</span><span class="o">=</span><span class="n">imu_config</span><span class="p">,</span>  <span class="c1"># Optional</span>
    <span class="n">start_time_imu</span><span class="o">=</span><span class="n">metadata_time_imu</span><span class="o">.</span><span class="n">start_iso8601</span>  <span class="c1"># Optional</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overlapping preprocessed data shapes:</span><span class="se">\n</span><span class="s2">- PPG data: </span><span class="si">{</span><span class="n">df_ppg_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;- Accelerometer data: </span><span class="si">{</span><span class="n">df_acc_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">df_ppg_proc</span><span class="p">,</span> <span class="n">df_acc_proc</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The tolerance for checking contiguous timestamps is set to 0.100 seconds for PPG data and 0.030 seconds for accelerometer data.
Original data shapes:
- PPG data: (1029375, 2)
- Accelerometer data: (3455331, 7)


Resampled: 3455331 -&gt; 3433961 rows at 100.0 Hz


Resampled: 1029374 -&gt; 1030188 rows at 30.0 Hz
Overlapping preprocessed data shapes:
- PPG data: (1030188, 2)
- Accelerometer data: (3433961, 4)
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>green</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000000</td>
      <td>-26.315811</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.033333</td>
      <td>91.335299</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.066667</td>
      <td>181.603416</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.100000</td>
      <td>225.760466</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.133333</td>
      <td>219.937282</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1030183</th>
      <td>34339.433333</td>
      <td>224556.234611</td>
    </tr>
    <tr>
      <th>1030184</th>
      <td>34339.466667</td>
      <td>210075.529517</td>
    </tr>
    <tr>
      <th>1030185</th>
      <td>34339.500000</td>
      <td>163811.629247</td>
    </tr>
    <tr>
      <th>1030186</th>
      <td>34339.533333</td>
      <td>94537.897763</td>
    </tr>
    <tr>
      <th>1030187</th>
      <td>34339.566667</td>
      <td>12915.304284</td>
    </tr>
  </tbody>
</table>
<p>1030188 rows × 2 columns</p>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>accelerometer_x</th>
      <th>accelerometer_y</th>
      <th>accelerometer_z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00</td>
      <td>-0.002324</td>
      <td>-0.001442</td>
      <td>-0.002116</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.01</td>
      <td>-0.000390</td>
      <td>-0.000914</td>
      <td>-0.007396</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.02</td>
      <td>0.000567</td>
      <td>0.002474</td>
      <td>-0.005445</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.03</td>
      <td>-0.000425</td>
      <td>0.002414</td>
      <td>-0.002099</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.04</td>
      <td>-0.002807</td>
      <td>-0.001408</td>
      <td>-0.000218</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>3433956</th>
      <td>34339.56</td>
      <td>-0.402941</td>
      <td>0.038710</td>
      <td>0.461449</td>
    </tr>
    <tr>
      <th>3433957</th>
      <td>34339.57</td>
      <td>-0.659832</td>
      <td>0.098696</td>
      <td>0.817136</td>
    </tr>
    <tr>
      <th>3433958</th>
      <td>34339.58</td>
      <td>-0.464138</td>
      <td>0.033607</td>
      <td>0.471552</td>
    </tr>
    <tr>
      <th>3433959</th>
      <td>34339.59</td>
      <td>-0.389065</td>
      <td>0.108485</td>
      <td>0.622471</td>
    </tr>
    <tr>
      <th>3433960</th>
      <td>34339.60</td>
      <td>-0.082625</td>
      <td>-0.014490</td>
      <td>0.119875</td>
    </tr>
  </tbody>
</table>
<p>3433961 rows × 4 columns</p>
</div>
</section>
<section id="step-2-extract-signal-quality-features">
<h2>Step 2: Extract signal quality features<a class="headerlink" href="#step-2-extract-signal-quality-features" title="Link to this heading"></a></h2>
<p>The preprocessed data is windowed into overlapping windows of length <code class="docutils literal notranslate"><span class="pre">ppg_config.window_length_s</span></code> with a window step of <code class="docutils literal notranslate"><span class="pre">ppg_config.window_step_length_s</span></code>. From the PPG windows, 10 time- and frequency domain features are extracted to assess PPG morphology. In case of using the accelerometer data (optional),  one relative power feature is calculated per window to assess periodic motion artifacts.</p>
<p>The detailed steps are encapsulated in <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/pipelines/pulse_rate_pipeline/index.html#paradigma.pipelines.pulse_rate_pipeline.extract_signal_quality_features"><code class="docutils literal notranslate"><span class="pre">extract_signal_quality_features</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pulse_rate_ppg_config</span> <span class="o">=</span> <span class="n">PulseRateConfig</span><span class="p">(</span>
    <span class="n">sensor</span><span class="o">=</span><span class="s1">&#39;ppg&#39;</span><span class="p">,</span>
    <span class="n">ppg_sampling_frequency</span><span class="o">=</span><span class="n">ppg_config</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">pulse_rate_acc_config</span> <span class="o">=</span> <span class="n">PulseRateConfig</span><span class="p">(</span>
    <span class="n">sensor</span><span class="o">=</span><span class="s1">&#39;imu&#39;</span><span class="p">,</span>
    <span class="n">imu_sampling_frequency</span><span class="o">=</span><span class="n">imu_config</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span>
    <span class="n">accelerometer_colnames</span><span class="o">=</span><span class="n">imu_config</span><span class="o">.</span><span class="n">accelerometer_colnames</span><span class="p">,</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The default window length for the signal quality feature extraction is &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;set to </span><span class="si">{</span><span class="n">pulse_rate_ppg_config</span><span class="o">.</span><span class="n">window_length_s</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The default step size for the signal quality feature extraction is &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;set to </span><span class="si">{</span><span class="n">pulse_rate_ppg_config</span><span class="o">.</span><span class="n">window_step_length_s</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>

<span class="c1"># Remove optional arguments if you don&#39;t have accelerometer data</span>
<span class="c1"># (set to None or remove arguments)</span>
<span class="n">df_features</span> <span class="o">=</span> <span class="n">extract_signal_quality_features</span><span class="p">(</span>
    <span class="n">df_ppg</span><span class="o">=</span><span class="n">df_ppg_proc</span><span class="p">,</span>
    <span class="n">df_acc</span><span class="o">=</span><span class="n">df_acc_proc</span><span class="p">,</span>
    <span class="n">ppg_config</span><span class="o">=</span><span class="n">pulse_rate_ppg_config</span><span class="p">,</span>
    <span class="n">acc_config</span><span class="o">=</span><span class="n">pulse_rate_acc_config</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">display</span><span class="p">(</span><span class="n">df_features</span><span class="p">)</span>

</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The default window length for the signal quality feature extraction is set to 6 seconds.
The default step size for the signal quality feature extraction is set to 1 seconds.
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>acc_power_ratio</th>
      <th>var</th>
      <th>mean</th>
      <th>median</th>
      <th>kurtosis</th>
      <th>skewness</th>
      <th>signal_to_noise</th>
      <th>auto_corr</th>
      <th>f_dom</th>
      <th>rel_power</th>
      <th>spectral_entropy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>0.026409</td>
      <td>1.145652e+05</td>
      <td>282.401234</td>
      <td>238.829637</td>
      <td>2.170853</td>
      <td>0.107401</td>
      <td>3.320049</td>
      <td>0.544165</td>
      <td>0.585938</td>
      <td>0.138454</td>
      <td>0.516336</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>0.023402</td>
      <td>1.102401e+05</td>
      <td>271.582177</td>
      <td>236.891936</td>
      <td>2.251393</td>
      <td>-0.029309</td>
      <td>3.041878</td>
      <td>0.491829</td>
      <td>0.585938</td>
      <td>0.160433</td>
      <td>0.511626</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2.0</td>
      <td>0.028592</td>
      <td>1.061479e+05</td>
      <td>262.348604</td>
      <td>225.915756</td>
      <td>2.415221</td>
      <td>0.216631</td>
      <td>2.818552</td>
      <td>0.469092</td>
      <td>0.585938</td>
      <td>0.167007</td>
      <td>0.525025</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>0.019296</td>
      <td>9.514719e+04</td>
      <td>245.089445</td>
      <td>203.417715</td>
      <td>2.481465</td>
      <td>0.110420</td>
      <td>2.677071</td>
      <td>0.415071</td>
      <td>0.585938</td>
      <td>0.170626</td>
      <td>0.550495</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.0</td>
      <td>0.020083</td>
      <td>7.393010e+04</td>
      <td>218.379138</td>
      <td>187.583266</td>
      <td>2.405921</td>
      <td>0.084566</td>
      <td>2.796140</td>
      <td>0.338369</td>
      <td>0.585938</td>
      <td>0.121113</td>
      <td>0.595214</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>34329</th>
      <td>34329.0</td>
      <td>0.110219</td>
      <td>8.176078e+06</td>
      <td>1613.021494</td>
      <td>438.201240</td>
      <td>6.122772</td>
      <td>-1.792336</td>
      <td>1.378694</td>
      <td>0.104389</td>
      <td>0.351562</td>
      <td>0.046616</td>
      <td>0.356027</td>
    </tr>
    <tr>
      <th>34330</th>
      <td>34330.0</td>
      <td>0.178742</td>
      <td>3.512188e+07</td>
      <td>3307.888927</td>
      <td>1069.775894</td>
      <td>8.160698</td>
      <td>1.746472</td>
      <td>1.442643</td>
      <td>0.142226</td>
      <td>0.351562</td>
      <td>0.049424</td>
      <td>0.371163</td>
    </tr>
    <tr>
      <th>34331</th>
      <td>34331.0</td>
      <td>0.153351</td>
      <td>1.181350e+08</td>
      <td>6648.535487</td>
      <td>2743.478312</td>
      <td>5.654373</td>
      <td>0.018587</td>
      <td>1.558314</td>
      <td>0.136803</td>
      <td>0.351562</td>
      <td>0.048211</td>
      <td>0.366386</td>
    </tr>
    <tr>
      <th>34332</th>
      <td>34332.0</td>
      <td>0.154910</td>
      <td>1.252829e+09</td>
      <td>20165.525309</td>
      <td>6452.244225</td>
      <td>6.805051</td>
      <td>-1.222184</td>
      <td>1.310088</td>
      <td>0.666123</td>
      <td>0.351562</td>
      <td>0.037812</td>
      <td>0.359105</td>
    </tr>
    <tr>
      <th>34333</th>
      <td>34333.0</td>
      <td>0.093221</td>
      <td>1.008217e+10</td>
      <td>42271.328020</td>
      <td>12552.656437</td>
      <td>23.756877</td>
      <td>4.167326</td>
      <td>1.212179</td>
      <td>0.044647</td>
      <td>0.585938</td>
      <td>0.113283</td>
      <td>0.632749</td>
    </tr>
  </tbody>
</table>
<p>34334 rows × 12 columns</p>
</div>
</section>
<section id="step-3-signal-quality-classification">
<h2>Step 3: Signal quality classification<a class="headerlink" href="#step-3-signal-quality-classification" title="Link to this heading"></a></h2>
<p>A trained logistic classifier is used to predict PPG signal quality and returns the <code class="docutils literal notranslate"><span class="pre">pred_sqa_proba</span></code>, which is the posterior probability of a PPG window to look like the typical PPG morphology (higher probability indicates toward the typical PPG morphology).
If accelerometer is used, the relative power feature from the accelerometer is compared to a threshold for periodic artifacts and therefore <code class="docutils literal notranslate"><span class="pre">pred_sqa_acc_label</span></code> is used to return a label indicating predicted periodic motion artifacts (label 0) or no periodic motion artifacts (label 1).</p>
<p>The classification step is implemented in <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/pipelines/pulse_rate_pipeline/index.html#paradigma.pipelines.pulse_rate_pipeline.signal_quality_classification"><code class="docutils literal notranslate"><span class="pre">signal_quality_classification</span></code></a>.</p>
<p><u><strong><em>Note on scale sensitivity</em></strong></u>
The PPG sensor used for developing this pipeline records in arbitrary units. Some features are scale sensitive and require rescaling when applying the pipeline to other datasets or PPG sensors.
In this pipeline, the logistic classifier for PPG morphology was trained on z-scored features, using the means (μ) and standard deviations (σ) from the Personalized Parkinson Project training set (documentation of the training set can be found in the Signal Quality Assessment section <a class="reference external" href="https://www.medrxiv.org/content/10.1101/2025.08.15.25333751v1.full-text">here</a>). These μ and σ values are stored in the <code class="docutils literal notranslate"><span class="pre">ppg_quality_classifier_package</span></code>. When applying the code to another dataset, users are advised to recalculate <strong><em>μ</em></strong> and <strong><em>σ</em></strong> for each feature on their (training) data and update the classifier package accordingly. Example code to recalculate the <strong><em>μ</em></strong> and <strong><em>σ</em></strong> can be found in the code cell below and in section 7.3.1. <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#standardization-or-mean-removal-and-variance-scaling">here</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span> <span class="o">=</span> <span class="n">PulseRateConfig</span><span class="p">()</span>

<span class="n">ppg_quality_classifier_package_filename</span> <span class="o">=</span> <span class="s1">&#39;ppg_quality_clf_package.pkl&#39;</span>
<span class="n">full_path_to_classifier_package</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">files</span><span class="p">(</span><span class="s1">&#39;paradigma&#39;</span><span class="p">)</span>
    <span class="o">/</span> <span class="s1">&#39;assets&#39;</span>
    <span class="o">/</span> <span class="n">ppg_quality_classifier_package_filename</span>
<span class="p">)</span>

<span class="c1"># Load the classifier package</span>
<span class="n">clf_package</span> <span class="o">=</span> <span class="n">ClassifierPackage</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">full_path_to_classifier_package</span><span class="p">)</span>

<span class="c1"># If you use a different sensor or dataset, you have to update the classifier</span>
<span class="c1"># package with the mu and sigma calculated on your training data.</span>
<span class="c1"># Example code to recalculate the mean and std to update the clf_package:</span>
<span class="c1"># import numpy as np</span>

<span class="c1"># # create random x_train for demonstration purposes, 100 samples and 10 features</span>
<span class="c1"># x_train = np.random.rand(100, 10)</span>
<span class="c1"># clf_package.update_scaler(x_train)</span>

<span class="n">df_sqa</span> <span class="o">=</span> <span class="n">signal_quality_classification</span><span class="p">(</span>
    <span class="n">df</span><span class="o">=</span><span class="n">df_features</span><span class="p">,</span>
    <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="n">clf_package</span><span class="o">=</span><span class="n">clf_package</span>
<span class="p">)</span>

<span class="n">df_sqa</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>pred_sqa_proba</th>
      <th>pred_sqa_acc_label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>1.121315e-02</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>7.126135e-03</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2.0</td>
      <td>7.017555e-03</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>4.134224e-03</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.0</td>
      <td>9.195340e-04</td>
      <td>1</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>34329</th>
      <td>34329.0</td>
      <td>1.782669e-08</td>
      <td>0</td>
    </tr>
    <tr>
      <th>34330</th>
      <td>34330.0</td>
      <td>2.078262e-06</td>
      <td>0</td>
    </tr>
    <tr>
      <th>34331</th>
      <td>34331.0</td>
      <td>1.190223e-07</td>
      <td>0</td>
    </tr>
    <tr>
      <th>34332</th>
      <td>34332.0</td>
      <td>1.383614e-08</td>
      <td>0</td>
    </tr>
    <tr>
      <th>34333</th>
      <td>34333.0</td>
      <td>7.587516e-07</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>34334 rows × 3 columns</p>
</div>
<section id="store-as-tsdf">
<h3>Store as TSDF<a class="headerlink" href="#store-as-tsdf" title="Link to this heading"></a></h3>
<p>The predicted probabilities (and optionally other features) can be stored and loaded in TSDF as demonstrated below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set &#39;path_to_data&#39; to the directory where you want to save the data</span>
<span class="n">metadata_time_store</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">TSDFMetadata</span><span class="p">(</span>
    <span class="n">metadata_time_ppg</span><span class="o">.</span><span class="n">get_plain_tsdf_dict_copy</span><span class="p">(),</span>
    <span class="n">path_to_prepared_data</span>
<span class="p">)</span>
<span class="n">metadata_values_store</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">TSDFMetadata</span><span class="p">(</span>
    <span class="n">metadata_values_ppg</span><span class="o">.</span><span class="n">get_plain_tsdf_dict_copy</span><span class="p">(),</span>
    <span class="n">path_to_prepared_data</span>
<span class="p">)</span>

<span class="c1"># Select the columns to be saved</span>
<span class="n">metadata_time_store</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="n">metadata_values_store</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pred_sqa_proba&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_sqa_acc_label&#39;</span><span class="p">]</span>

<span class="c1"># Set the units</span>
<span class="n">metadata_time_store</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Relative seconds&#39;</span><span class="p">]</span>
<span class="n">metadata_values_store</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Unitless&#39;</span><span class="p">,</span> <span class="s1">&#39;Unitless&#39;</span><span class="p">]</span>
<span class="n">metadata_time_store</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="nb">float</span>
<span class="n">metadata_values_store</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="nb">float</span>

<span class="c1"># Set the filenames</span>
<span class="n">meta_store_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">_meta.json&#39;</span>
<span class="n">values_store_filename</span> <span class="o">=</span> <span class="n">meta_store_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_meta.json&#39;</span><span class="p">,</span> <span class="s1">&#39;_values.bin&#39;</span><span class="p">)</span>
<span class="n">time_store_filename</span> <span class="o">=</span> <span class="n">meta_store_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_meta.json&#39;</span><span class="p">,</span> <span class="s1">&#39;_time.bin&#39;</span><span class="p">)</span>

<span class="n">metadata_values_store</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">values_store_filename</span>
<span class="n">metadata_time_store</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">time_store_filename</span>

<span class="n">write_df_data</span><span class="p">(</span>
    <span class="n">metadata_time_store</span><span class="p">,</span>
    <span class="n">metadata_values_store</span><span class="p">,</span>
    <span class="n">path_to_prepared_data</span><span class="p">,</span>
    <span class="n">meta_store_filename</span><span class="p">,</span>
    <span class="n">df_sqa</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df_sqa</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_tsdf_dataframe</span><span class="p">(</span>
    <span class="n">path_to_prepared_data</span><span class="p">,</span>
    <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="p">)</span>
<span class="n">df_sqa</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>pred_sqa_proba</th>
      <th>pred_sqa_acc_label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>0.011213</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>0.007126</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2.0</td>
      <td>0.007018</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>0.004134</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.0</td>
      <td>0.000920</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</section>
</section>
<section id="step-4-pulse-rate-estimation">
<h2>Step 4: Pulse rate estimation<a class="headerlink" href="#step-4-pulse-rate-estimation" title="Link to this heading"></a></h2>
<p>For pulse rate estimation, we extract segments of <code class="docutils literal notranslate"><span class="pre">config.tfd_length</span></code> using <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/pipelines/pulse_rate_pipeline/index.html#paradigma.pipelines.pulse_rate_pipeline.estimate_pulse_rate">estimate_pulse_rate</a>. We calculate the smoothed-pseudo Wigner-Ville Distribution (SPWVD) to obtain the frequency content of the PPG signal over time. We extract for every timestamp in the SPWVD the frequency with the highest power. For every non-overlapping 2 s window we average the corresponding frequencies to obtain a pulse rate per window.</p>
<p>Note: for the test data we set the tfd_length to 10 s instead of the default of 30 s, because the small PPP test data doesn’t have 30 s of consecutive high-quality PPG data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;The standard default minimal window length for the pulse rate &quot;</span>
    <span class="s2">&quot;extraction is set to&quot;</span><span class="p">,</span> <span class="n">pulse_rate_ppg_config</span><span class="o">.</span><span class="n">tfd_length</span><span class="p">,</span> <span class="s2">&quot;seconds.&quot;</span>
<span class="p">)</span>

<span class="n">df_pr</span> <span class="o">=</span> <span class="n">estimate_pulse_rate</span><span class="p">(</span>
    <span class="n">df_sqa</span><span class="o">=</span><span class="n">df_sqa</span><span class="p">,</span>
    <span class="n">df_ppg_preprocessed</span><span class="o">=</span><span class="n">df_ppg_proc</span><span class="p">,</span>
    <span class="n">config</span><span class="o">=</span><span class="n">pulse_rate_ppg_config</span>
<span class="p">)</span>

<span class="n">df_pr</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The standard default minimal window length for the pulse rate extraction is set to 30 seconds.
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>pulse_rate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>47.0</td>
      <td>80.372915</td>
    </tr>
    <tr>
      <th>1</th>
      <td>49.0</td>
      <td>79.769382</td>
    </tr>
    <tr>
      <th>2</th>
      <td>51.0</td>
      <td>79.136408</td>
    </tr>
    <tr>
      <th>3</th>
      <td>53.0</td>
      <td>78.606477</td>
    </tr>
    <tr>
      <th>4</th>
      <td>55.0</td>
      <td>77.870461</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>801</th>
      <td>32876.0</td>
      <td>78.220133</td>
    </tr>
    <tr>
      <th>802</th>
      <td>32878.0</td>
      <td>78.047301</td>
    </tr>
    <tr>
      <th>803</th>
      <td>32880.0</td>
      <td>78.047301</td>
    </tr>
    <tr>
      <th>804</th>
      <td>32882.0</td>
      <td>78.238326</td>
    </tr>
    <tr>
      <th>805</th>
      <td>32884.0</td>
      <td>78.556701</td>
    </tr>
  </tbody>
</table>
<p>806 rows × 2 columns</p>
</div>
<section id="run-steps-1-4-for-multiple-segments">
<h3>Run steps 1 - 4 for multiple segments <a id='multiple_segments_cell'></a><a class="headerlink" href="#run-steps-1-4-for-multiple-segments" title="Link to this heading"></a></h3>
<p>If your data is also stored in multiple segments, you can modify <code class="docutils literal notranslate"><span class="pre">segments</span></code> in the cell below to a list of the filenames of your respective segmented data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the path to where the prepared data is saved</span>
<span class="n">path_to_prepared_data</span> <span class="o">=</span>  <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;../../example_data/verily&#39;</span><span class="p">)</span>

<span class="n">ppg_prefix</span> <span class="o">=</span> <span class="s1">&#39;ppg&#39;</span>
<span class="n">imu_prefix</span> <span class="o">=</span> <span class="s1">&#39;imu&#39;</span>

<span class="c1"># Set the path to the classifier package</span>
<span class="n">ppg_quality_classifier_package_filename</span> <span class="o">=</span> <span class="s1">&#39;ppg_quality_clf_package.pkl&#39;</span>
<span class="n">full_path_to_classifier_package</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">files</span><span class="p">(</span><span class="s1">&#39;paradigma&#39;</span><span class="p">)</span>
    <span class="o">/</span> <span class="s1">&#39;assets&#39;</span>
    <span class="o">/</span> <span class="n">ppg_quality_classifier_package_filename</span>
<span class="p">)</span>

<span class="c1"># Create a list of dataframes to store the estimated pulse rates of all segments</span>
<span class="n">list_df_pr</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0001&#39;</span><span class="p">,</span> <span class="s1">&#39;0002&#39;</span><span class="p">]</span> <span class="c1"># list with all available segments</span>

<span class="k">for</span> <span class="n">segment_nr</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>

    <span class="c1"># Load the data</span>
    <span class="n">df_ppg</span><span class="p">,</span> <span class="n">metadata_time_ppg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_tsdf_dataframe</span><span class="p">(</span>
        <span class="n">path_to_data</span><span class="o">=</span><span class="n">path_to_prepared_data</span> <span class="o">/</span> <span class="n">ppg_prefix</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;PPG_segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="n">df_imu</span><span class="p">,</span> <span class="n">metadata_time_imu</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_tsdf_dataframe</span><span class="p">(</span>
        <span class="n">path_to_data</span><span class="o">=</span><span class="n">path_to_prepared_data</span> <span class="o">/</span> <span class="n">imu_prefix</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;IMU_segment</span><span class="si">{</span><span class="n">segment_nr</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="c1"># Drop the gyroscope columns from the IMU data</span>
    <span class="n">cols_to_drop</span> <span class="o">=</span> <span class="n">df_imu</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="s1">&#39;^gyroscope_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">df_acc</span> <span class="o">=</span> <span class="n">df_imu</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cols_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 1: Preprocess the data</span>

    <span class="n">ppg_config</span> <span class="o">=</span> <span class="n">PPGConfig</span><span class="p">()</span>
    <span class="n">imu_config</span> <span class="o">=</span> <span class="n">IMUConfig</span><span class="p">()</span>

    <span class="n">df_ppg_proc</span><span class="p">,</span> <span class="n">df_acc_proc</span> <span class="o">=</span> <span class="n">preprocess_ppg_data</span><span class="p">(</span>
        <span class="n">df_ppg</span><span class="o">=</span><span class="n">df_ppg</span><span class="p">,</span>
        <span class="n">df_acc</span><span class="o">=</span><span class="n">df_acc</span><span class="p">,</span>
        <span class="n">ppg_config</span><span class="o">=</span><span class="n">ppg_config</span><span class="p">,</span>
        <span class="n">imu_config</span><span class="o">=</span><span class="n">imu_config</span><span class="p">,</span>
        <span class="n">start_time_ppg</span><span class="o">=</span><span class="n">metadata_time_ppg</span><span class="o">.</span><span class="n">start_iso8601</span><span class="p">,</span>
        <span class="n">start_time_imu</span><span class="o">=</span><span class="n">metadata_time_imu</span><span class="o">.</span><span class="n">start_iso8601</span>
    <span class="p">)</span>

    <span class="c1"># 2: Extract signal quality features</span>
    <span class="n">ppg_config</span> <span class="o">=</span> <span class="n">PulseRateConfig</span><span class="p">(</span>
        <span class="n">sensor</span><span class="o">=</span><span class="s1">&#39;ppg&#39;</span><span class="p">,</span>
        <span class="n">ppg_sampling_frequency</span><span class="o">=</span><span class="n">ppg_config</span><span class="o">.</span><span class="n">sampling_frequency</span>
    <span class="p">)</span>
    <span class="n">acc_config</span> <span class="o">=</span> <span class="n">PulseRateConfig</span><span class="p">(</span>
        <span class="n">sensor</span><span class="o">=</span><span class="s1">&#39;imu&#39;</span><span class="p">,</span>
        <span class="n">imu_sampling_frequency</span><span class="o">=</span><span class="n">imu_config</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span>
        <span class="n">accelerometer_colnames</span><span class="o">=</span><span class="n">imu_config</span><span class="o">.</span><span class="n">accelerometer_colnames</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df_features</span> <span class="o">=</span> <span class="n">extract_signal_quality_features</span><span class="p">(</span>
        <span class="n">df_ppg</span><span class="o">=</span><span class="n">df_ppg_proc</span><span class="p">,</span>
        <span class="n">df_acc</span><span class="o">=</span><span class="n">df_acc_proc</span><span class="p">,</span>
        <span class="n">ppg_config</span><span class="o">=</span><span class="n">ppg_config</span><span class="p">,</span>
        <span class="n">acc_config</span><span class="o">=</span><span class="n">acc_config</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># 3: Signal quality classification</span>
    <span class="n">df_sqa</span> <span class="o">=</span> <span class="n">signal_quality_classification</span><span class="p">(</span>
        <span class="n">df</span><span class="o">=</span><span class="n">df_features</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="n">ppg_config</span><span class="p">,</span>
        <span class="n">clf_package</span><span class="o">=</span><span class="n">clf_package</span>
    <span class="p">)</span>

    <span class="c1"># 4: Estimate pulse rate</span>
    <span class="n">df_pr</span> <span class="o">=</span> <span class="n">estimate_pulse_rate</span><span class="p">(</span>
        <span class="n">df_sqa</span><span class="o">=</span><span class="n">df_sqa</span><span class="p">,</span>
        <span class="n">df_ppg_preprocessed</span><span class="o">=</span><span class="n">df_ppg_proc</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="n">ppg_config</span>
    <span class="p">)</span>

    <span class="c1"># Add the hr estimations of the current segment to the list</span>
    <span class="n">df_pr</span><span class="p">[</span><span class="s1">&#39;segment_nr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_nr</span>
    <span class="n">list_df_pr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_pr</span><span class="p">)</span>

<span class="n">df_pr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">list_df_pr</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Resampled: 3455331 -&gt; 3433961 rows at 100.0 Hz


Resampled: 1029374 -&gt; 1030188 rows at 30.0 Hz


Resampled: 7434685 -&gt; 7388945 rows at 100.0 Hz


Resampled: 2214444 -&gt; 2216683 rows at 30.0 Hz
</pre></div>
</div>
</section>
</section>
<section id="step-5-pulse-rate-aggregation">
<h2>Step 5: Pulse rate aggregation<a class="headerlink" href="#step-5-pulse-rate-aggregation" title="Link to this heading"></a></h2>
<p>The final step is to aggregate all 2 s pulse rate estimates using <a class="reference external" href="https://biomarkersparkinson.github.io/paradigma/autoapi/paradigma/pipelines/pulse_rate_pipeline/index.html#paradigma.pipelines.pulse_rate_pipeline.aggregate_pulse_rate">aggregate_pulse_rate</a>. In the current example, the mode and 99th percentile are calculated. We hypothesize that the mode gives representation of the resting pulse rate while the 99th percentile indicates the maximum pulse rate. In Parkinson’s disease, we expect that these two measures could reflect autonomic (dys)functioning. The <code class="docutils literal notranslate"><span class="pre">nr_pr_est</span></code> in the metadata indicates based on how many 2 s windows these aggregates are determined.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pr_values</span> <span class="o">=</span> <span class="n">df_pr</span><span class="p">[</span><span class="s1">&#39;pulse_rate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">df_pr_agg</span> <span class="o">=</span> <span class="n">aggregate_pulse_rate</span><span class="p">(</span>
    <span class="n">pr_values</span><span class="o">=</span><span class="n">pr_values</span><span class="p">,</span>
    <span class="n">aggregates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;99p&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">df_pr_agg</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
  &quot;metadata&quot;: {
    &quot;nr_pr_est&quot;: 8660
  },
  &quot;pr_aggregates&quot;: {
    &quot;mode_pulse_rate&quot;: 63.59175662414131,
    &quot;99p_pulse_rate&quot;: 85.77263444520081
  }
}
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Erik Post, Kars Veldkamp, Nienke Timmermans, Diogo Coutinho Soriano, Vedran Kasalica, Peter Kok, and Luc Evers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>