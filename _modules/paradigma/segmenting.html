<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>paradigma.segmenting &mdash; paradigma  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            paradigma
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/data_preparation.html">Data preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/gait_analysis.html">Gait analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/tremor_analysis.html">Tremor analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/heart_rate_analysis.html">Heart rate analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guides/config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/coordinate_system.html">Coordinate System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">paradigma</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">paradigma.segmenting</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for paradigma.segmenting</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">paradigma.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataColumns</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<div class="viewcode-block" id="tabulate_windows">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.tabulate_windows">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tabulate_windows</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">window_length_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">window_step_length_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the given DataFrame into overlapping windows of specified length and step size.</span>

<span class="sd">    This function extracts windows of data from the specified columns of the DataFrame, based on</span>
<span class="sd">    the window length and step size provided in the configuration. The windows are returned in</span>
<span class="sd">    a 3D NumPy array, where the first dimension represents the window index, the second dimension</span>
<span class="sd">    represents the time steps within the window, and the third dimension represents the columns </span>
<span class="sd">    of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The input DataFrame containing the data to be windowed.</span>
<span class="sd">    columns : list of str</span>
<span class="sd">        A list of column names from the DataFrame that will be used for windowing.</span>
<span class="sd">    window_length_s : float</span>
<span class="sd">        The length of each window in seconds.</span>
<span class="sd">    window_step_length_s : float</span>
<span class="sd">        The step size between consecutive windows in seconds.</span>
<span class="sd">    fs : int</span>
<span class="sd">        The sampling frequency of the data in Hz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A 3D NumPy array of shape (n_windows, window_size, n_columns), where:</span>
<span class="sd">        - `n_windows` is the number of windows that can be formed from the data.</span>
<span class="sd">        - `window_size` is the length of each window in terms of the number of time steps.</span>
<span class="sd">        - `n_columns` is the number of columns in the input DataFrame specified by `columns`.</span>
<span class="sd">        </span>
<span class="sd">        If the length of the data is shorter than the specified window size, an empty array is returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function uses `np.lib.stride_tricks.sliding_window_view` to generate sliding windows of data.</span>
<span class="sd">    The step size is applied to extract windows at intervals.</span>
<span class="sd">    If the data is insufficient for at least one window, an empty array will be returned.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    config = Config(window_length_s=5, window_step_length_s=1, sampling_frequency=100)</span>
<span class="sd">    df = pd.DataFrame({&#39;col1&#39;: np.random.randn(100), &#39;col2&#39;: np.random.randn(100)})</span>
<span class="sd">    columns = [&#39;col1&#39;, &#39;col2&#39;]</span>
<span class="sd">    windows = tabulate_windows(config, df, columns)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_length_s</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">window_step_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_step_length_s</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Check if data length is sufficient</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">window_size</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">))</span>  <span class="c1"># Return an empty array if insufficient data</span>
    
    <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">sliding_window_view</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">window_shape</span><span class="o">=</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">)</span>
        <span class="p">)[::</span><span class="n">window_step_size</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    
    <span class="c1"># Ensure 3D shape (n_windows, window_size, n_columns)</span>
    <span class="k">if</span> <span class="n">windows</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Single window case</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># Add a new axis at the start</span>

    <span class="k">return</span> <span class="n">windows</span></div>



<div class="viewcode-block" id="tabulate_windows_legacy">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.tabulate_windows_legacy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tabulate_windows_legacy</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">agg_func</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Efficiently creates a windowed dataframe from the input dataframe using vectorized operations.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        df: The input dataframe, where each row represents a timestamp (0.01 sec).</span>
<span class="sd">        window_length_s: The number of seconds per window.</span>
<span class="sd">        window_step_length_s: The number of seconds to shift between windows.</span>
<span class="sd">        single_value_cols: List of columns where a single value (e.g., mean) is needed.</span>
<span class="sd">        list_value_cols: List of columns where all 600 values should be stored in a list.</span>
<span class="sd">        agg_func: Aggregation function for single-value columns (e.g., &#39;mean&#39;, &#39;first&#39;).</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        The windowed dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If single_value_cols or list_value_cols is None, default to an empty list</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">single_value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config</span><span class="o">.</span><span class="n">single_value_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">list_value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config</span><span class="o">.</span><span class="n">list_value_cols</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">window_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">window_length_s</span> <span class="o">*</span> <span class="n">config</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">)</span>
    <span class="n">window_step_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">window_step_length_s</span> <span class="o">*</span> <span class="n">config</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">)</span>

    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window_length</span> <span class="o">&gt;</span> <span class="n">n_rows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Window size (</span><span class="si">{</span><span class="n">window_length</span><span class="si">}</span><span class="s2">) cannot be greater than the number of rows (</span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">) in the dataframe.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create indices for window start positions </span>
    <span class="n">window_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_rows</span> <span class="o">-</span> <span class="n">window_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window_step_size</span><span class="p">)</span>
    
    <span class="c1"># Prepare the result for the final DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Handle single value columns with vectorized operations</span>
    <span class="n">agg_func_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
        <span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="c1"># Check if agg_func is a callable (custom function) or get the function from the map</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">agg_func</span><span class="p">):</span>
        <span class="n">agg_func_np</span> <span class="o">=</span> <span class="n">agg_func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">agg_func_np</span> <span class="o">=</span> <span class="n">agg_func_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">agg_func</span><span class="p">,</span> <span class="n">agg_func_map</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>  <span class="c1"># Default to &#39;mean&#39; if agg_func is not recognized</span>

        
    <span class="k">for</span> <span class="n">window_nr</span><span class="p">,</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">window_starts</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">window_length</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="n">agg_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;window_nr&#39;</span><span class="p">:</span> <span class="n">window_nr</span><span class="p">,</span>
            <span class="s1">&#39;window_start&#39;</span><span class="p">:</span> <span class="n">window</span><span class="p">[</span><span class="n">DataColumns</span><span class="o">.</span><span class="n">TIME</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;window_end&#39;</span><span class="p">:</span> <span class="n">window</span><span class="p">[</span><span class="n">DataColumns</span><span class="o">.</span><span class="n">TIME</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
        
        <span class="c1"># Aggregate single-value columns</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">single_value_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">window</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>  <span class="c1"># Only process columns that exist in the window</span>
                <span class="n">agg_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_func_np</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># Collect list-value columns efficiently using numpy slicing</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">list_value_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">window</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>  <span class="c1"># Only process columns that exist in the window</span>
                <span class="n">agg_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">window</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_data</span><span class="p">)</span>
    
    <span class="c1"># Convert result list into a DataFrame</span>
    <span class="n">windowed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    
    <span class="c1"># Ensure the column order is as desired: window_nr, window_start, window_end, pre_or_post, and then the rest</span>
    <span class="n">desired_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;window_nr&#39;</span><span class="p">,</span> <span class="s1">&#39;window_start&#39;</span><span class="p">,</span> <span class="s1">&#39;window_end&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">single_value_cols</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">list_value_cols</span>
    
    <span class="k">return</span> <span class="n">windowed_df</span><span class="p">[</span><span class="n">desired_order</span><span class="p">]</span></div>



<div class="viewcode-block" id="create_segments">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.create_segments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_segments</span><span class="p">(</span>
        <span class="n">time_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">max_segment_gap_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="c1"># Calculate the difference between consecutive time values</span>
    <span class="n">time_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="c1"># Create a boolean mask for where the gap exceeds the threshold</span>
    <span class="n">gap_exceeds</span> <span class="o">=</span> <span class="n">time_diff</span> <span class="o">&gt;</span> <span class="n">max_segment_gap_s</span>

    <span class="c1"># Create the segment number based on the cumulative sum of the gap_exceeds mask</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="n">gap_exceeds</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 to start enumeration from 1</span>

    <span class="k">return</span> <span class="n">segments</span></div>



<div class="viewcode-block" id="discard_segments">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.discard_segments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">discard_segments</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">segment_nr_colname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">min_segment_length_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;timestamps&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove segments smaller than a specified size and reset segment enumeration.</span>

<span class="sd">    This function filters out segments from the DataFrame that are smaller than a </span>
<span class="sd">    given minimum size, based on the configuration. After removing small segments, </span>
<span class="sd">    the segment numbers are reset to start from 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    config : object</span>
<span class="sd">        A configuration object containing:</span>
<span class="sd">        - `min_segment_length_s`: The minimum segment length in seconds.</span>
<span class="sd">        - `sampling_frequency`: The sampling frequency in Hz.</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The input DataFrame containing a segment column and time series data.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        The format of the input data, either &#39;timestamps&#39; or &#39;windows&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A filtered DataFrame where small segments have been removed and segment </span>
<span class="sd">        numbers have been reset to start from 1.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    config = Config(min_segment_length_s=2, sampling_frequency=100, segment_nr_colname=&#39;segment&#39;)</span>
<span class="sd">    df = pd.DataFrame({</span>
<span class="sd">        &#39;segment&#39;: [1, 1, 2, 2, 2],</span>
<span class="sd">        &#39;time&#39;: [0, 1, 2, 3, 4]</span>
<span class="sd">    })</span>
<span class="sd">    df_filtered = discard_segments(config, df)</span>
<span class="sd">    # Result:</span>
<span class="sd">    #   segment  time</span>
<span class="sd">    # 0       1     0</span>
<span class="sd">    # 1       1     1</span>
<span class="sd">    # 2       2     2</span>
<span class="sd">    # 3       2     3</span>
<span class="sd">    # 4       2     4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Minimum segment size in number of samples</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;timestamps&#39;</span><span class="p">:</span>
        <span class="n">min_samples</span> <span class="o">=</span> <span class="n">min_segment_length_s</span> <span class="o">*</span> <span class="n">fs</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;windows&#39;</span><span class="p">:</span>
        <span class="n">min_samples</span> <span class="o">=</span> <span class="n">min_segment_length_s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid format. Must be &#39;timestamps&#39; or &#39;windows&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Group by segment and filter out small segments in one step</span>
    <span class="n">valid_segment_mask</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">segment_nr_colname</span><span class="p">)[</span><span class="n">segment_nr_colname</span><span class="p">]</span>
        <span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_samples</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">valid_segment_mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Reset segment numbers in a single step</span>
    <span class="n">unique_segments</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">segment_nr_colname</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">df</span><span class="p">[</span><span class="n">segment_nr_colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_segments</span>

    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="categorize_segments">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.categorize_segments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">categorize_segments</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;timestamps&#39;</span><span class="p">,</span> <span class="n">window_step_length_s</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Categorize segments based on their duration.</span>

<span class="sd">    This function categorizes segments into four categories based on their duration </span>
<span class="sd">    in seconds. The categories are defined as:</span>
<span class="sd">    - Category 1: Segments shorter than 5 seconds</span>
<span class="sd">    - Category 2: Segments between 5 and 10 seconds</span>
<span class="sd">    - Category 3: Segments between 10 and 20 seconds</span>
<span class="sd">    - Category 4: Segments longer than 20 seconds</span>

<span class="sd">    The duration of each segment is calculated based on the sampling frequency and </span>
<span class="sd">    the number of rows (data points) in the segment.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The input DataFrame containing the segment column with segment numbers.</span>
<span class="sd">    config : object</span>
<span class="sd">        A configuration object containing `sampling_frequency`.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        The format of the input data, either &#39;timestamps&#39; or &#39;windows&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.Series</span>
<span class="sd">        A Series containing the category for each segment:</span>
<span class="sd">        - &#39;short&#39; for segments &lt; 5 seconds</span>
<span class="sd">        - &#39;moderately_long&#39; for segments between 5 and 10 seconds</span>
<span class="sd">        - &#39;long&#39; for segments between 10 and 20 seconds</span>
<span class="sd">        - &#39;very_long&#39; for segments &gt; 20 seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;windows&#39;</span> <span class="ow">and</span> <span class="n">window_step_length_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window step length must be provided for &#39;windows&#39; format.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Define duration thresholds in seconds</span>
    <span class="n">d_max_duration</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;short&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s1">&#39;moderately_long&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s1">&#39;long&#39;</span><span class="p">:</span> <span class="mi">20</span>
    <span class="p">}</span>
    
    <span class="c1"># Convert thresholds to rows if format is &#39;timestamps&#39;</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;timestamps&#39;</span><span class="p">:</span>
        <span class="n">d_max_duration</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="n">fs</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d_max_duration</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># Count rows per segment</span>
    <span class="n">segment_sizes</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">DataColumns</span><span class="o">.</span><span class="n">SEGMENT_NR</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>

    <span class="c1"># Convert segment sizes to duration in seconds</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;windows&#39;</span><span class="p">:</span>
        <span class="n">segment_sizes</span> <span class="o">*=</span> <span class="n">window_step_length_s</span>

    <span class="c1"># Group by the segment column and apply the categorization</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">categorize</span><span class="p">(</span><span class="n">segment_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">segment_size</span> <span class="o">&lt;</span> <span class="n">d_max_duration</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;short&#39;</span>
        <span class="k">elif</span> <span class="n">segment_size</span> <span class="o">&lt;</span> <span class="n">d_max_duration</span><span class="p">[</span><span class="s1">&#39;moderately_long&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;moderately_long&#39;</span>
        <span class="k">elif</span> <span class="n">segment_size</span> <span class="o">&lt;</span> <span class="n">d_max_duration</span><span class="p">[</span><span class="s1">&#39;long&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;long&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;very_long&#39;</span>

    <span class="c1"># Apply categorization to the DataFrame</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">DataColumns</span><span class="o">.</span><span class="n">SEGMENT_NR</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">segment_sizes</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">categorize</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowedDataExtractor">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.WindowedDataExtractor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WindowedDataExtractor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class for extracting specific column indices and slices </span>
<span class="sd">    from a list of windowed column names.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    column_indices : dict</span>
<span class="sd">        A dictionary mapping column names to their indices.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    get_index(col)</span>
<span class="sd">        Returns the index of a specific column.</span>
<span class="sd">    get_slice(cols)</span>
<span class="sd">        Returns a slice object for a range of consecutive columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windowed_cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the WindowedDataExtractor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        windowed_cols : list of str</span>
<span class="sd">            A list of column names in the windowed data.</span>

<span class="sd">        Raises</span>
<span class="sd">         ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of `windowed_cols` is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">windowed_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The list of windowed columns cannot be empty.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">windowed_cols</span><span class="p">)}</span>

<div class="viewcode-block" id="WindowedDataExtractor.get_index">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.WindowedDataExtractor.get_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index of a specific column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col : str</span>
<span class="sd">            The name of the column to retrieve the index for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index of the specified column.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the column is not found in the `windowed_cols` list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; not found in windowed_cols.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span><span class="p">[</span><span class="n">col</span><span class="p">]</span></div>


<div class="viewcode-block" id="WindowedDataExtractor.get_slice">
<a class="viewcode-back" href="../../autoapi/paradigma/segmenting/index.html#paradigma.segmenting.WindowedDataExtractor.get_slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a slice object for a range of consecutive columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list of str</span>
<span class="sd">            A list of consecutive column names to define the slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slice</span>
<span class="sd">            A slice object spanning the indices of the given columns.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one or more columns in `cols` are not found in the `windowed_cols` list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following columns are missing from windowed_cols: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span><span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_indices</span><span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Erik Post, Kars Veldkamp, Nienke Timmermans, Diogo Coutinho Soriano, Vedran Kasalica, Peter Kok, and Luc Evers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>