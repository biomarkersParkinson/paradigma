paradigma.gait_analysis
=======================

.. py:module:: paradigma.gait_analysis


Classes
-------

.. autoapisummary::

   paradigma.gait_analysis.DataColumns
   paradigma.gait_analysis.GaitFeatureExtractionConfig
   paradigma.gait_analysis.GaitDetectionConfig
   paradigma.gait_analysis.ArmSwingFeatureExtractionConfig
   paradigma.gait_analysis.ArmSwingDetectionConfig
   paradigma.gait_analysis.ArmSwingQuantificationConfig


Functions
---------

.. autoapisummary::

   paradigma.gait_analysis.generate_statistics
   paradigma.gait_analysis.generate_std_norm
   paradigma.gait_analysis.compute_fft
   paradigma.gait_analysis.signal_to_ffts
   paradigma.gait_analysis.compute_power_in_bandwidth
   paradigma.gait_analysis.compute_perc_power
   paradigma.gait_analysis.get_dominant_frequency
   paradigma.gait_analysis.compute_power
   paradigma.gait_analysis.generate_cepstral_coefficients
   paradigma.gait_analysis.pca_transform_gyroscope
   paradigma.gait_analysis.compute_angle
   paradigma.gait_analysis.remove_moving_average_angle
   paradigma.gait_analysis.extract_angle_extremes
   paradigma.gait_analysis.extract_range_of_motion
   paradigma.gait_analysis.extract_peak_angular_velocity
   paradigma.gait_analysis.aggregate_segments
   paradigma.gait_analysis.create_window
   paradigma.gait_analysis.tabulate_windows
   paradigma.gait_analysis.create_segments
   paradigma.gait_analysis.discard_segments
   paradigma.gait_analysis.get_end_iso8601
   paradigma.gait_analysis.write_data
   paradigma.gait_analysis.read_metadata
   paradigma.gait_analysis.extract_temporal_domain_features
   paradigma.gait_analysis.extract_spectral_domain_features
   paradigma.gait_analysis.extract_gait_features
   paradigma.gait_analysis.detect_gait
   paradigma.gait_analysis.extract_arm_swing_features
   paradigma.gait_analysis.detect_arm_swing
   paradigma.gait_analysis.quantify_arm_swing
   paradigma.gait_analysis.aggregate_weekly_arm_swing


Module Contents
---------------

.. py:class:: DataColumns

   Enum for the data channels in tsdf.


   .. py:attribute:: ACCELEROMETER_X
      :value: 'accelerometer_x'



   .. py:attribute:: ACCELEROMETER_Y
      :value: 'accelerometer_y'



   .. py:attribute:: ACCELEROMETER_Z
      :value: 'accelerometer_z'



   .. py:attribute:: GYROSCOPE_X
      :value: 'gyroscope_x'



   .. py:attribute:: GYROSCOPE_Y
      :value: 'gyroscope_y'



   .. py:attribute:: GYROSCOPE_Z
      :value: 'gyroscope_z'



   .. py:attribute:: PPG
      :value: 'green'



   .. py:attribute:: TIME
      :value: 'time'



.. py:class:: GaitFeatureExtractionConfig

   .. py:method:: set_sensor(sensor: str) -> None

      Sets the sensor and derived filenames



   .. py:method:: set_sampling_frequency(sampling_frequency: int) -> None

      Sets the sampling frequency and derived variables



.. py:class:: GaitDetectionConfig

.. py:class:: ArmSwingFeatureExtractionConfig

   .. py:method:: initialize_window_length_fields(window_length_s: int) -> None


   .. py:method:: initialize_sampling_frequency_fields(sampling_frequency: int) -> None


   .. py:method:: initialize_column_names(time_colname='time', pred_gait_colname='pred_gait', angle_smooth_colname='angle_smooth', angle_colname='angle', velocity_colname='velocity', segment_nr_colname='segment_nr') -> None


   .. py:method:: set_sensor(sensor: str) -> None

      Sets the sensor and derived filenames



.. py:class:: ArmSwingDetectionConfig

.. py:class:: ArmSwingQuantificationConfig

.. py:function:: generate_statistics(sensor_col: pandas.Series, statistic: str) -> list

   Generate statistics for a single sensor and axis. The function is used with the apply function in pandas.

   :param sensor_col: The sensor column to be aggregated (e.g. x-axis of accelerometer)
   :type sensor_col: pd.Series
   :param statistic: The statistic to be computed [mean, std, max, min]
   :type statistic: str

   :returns: The aggregated statistics
   :rtype: list


.. py:function:: generate_std_norm(df: pandas.DataFrame, cols: list) -> pandas.Series

   Generate the standard deviation of the norm of the accelerometer axes.

   :param df: The dataframe containing the accelerometer axes
   :type df: pd.DataFrame
   :param cols: The names of the columns containing the accelerometer axes
   :type cols: list

   :returns: The standard deviation of the norm of the accelerometer axes
   :rtype: pd.Series


.. py:function:: compute_fft(values: list, window_type: str = 'hann', sampling_frequency: int = 100) -> tuple

   Compute the Fast Fourier Transform (FFT) of a signal.

   :param values: The values of the signal (e.g., accelerometer data) of a single window.
   :type values: list
   :param window_type: The type of window to be used for the FFT (default: 'hann')
   :type window_type: str
   :param sampling_frequency: The sampling frequency of the signal (default: 100)
   :type sampling_frequency: int

   :returns: The FFT values and the corresponding frequencies
   :rtype: tuple


.. py:function:: signal_to_ffts(sensor_col: pandas.Series, window_type: str = 'hann', sampling_frequency: int = 100) -> tuple

   Compute the Fast Fourier Transform (FFT) of a signal per window (can probably be combined with compute_fft and simplified).

   :param sensor_col: The sensor column to be transformed (e.g. x-axis of accelerometer)
   :type sensor_col: pd.Series
   :param window_type: The type of window to be used for the FFT (default: 'hann')
   :type window_type: str
   :param sampling_frequency: The sampling frequency of the signal (default: 100)
   :type sampling_frequency: int

   :returns: Lists of FFT values and corresponding frequencies which can be concatenated as column to the dataframe
   :rtype: tuple


.. py:function:: compute_power_in_bandwidth(sensor_col: list, fmin: int, fmax: int, sampling_frequency: int = 100, window_type: str = 'hann') -> float

   Note: sensor_col is a single cell (which corresponds to a single window) of sensor_col, as it is used with apply function.
   Probably we want a smarter way of doing this.

   Computes the power in a specific frequency band for a specified sensor and axis.

   :param sensor_col: The sensor column to be transformed (e.g. x-axis of accelerometer). This corresponds to a single window, which is a single row of the dataframe,
                      and contains values of individual timestamps composing the window.
   :type sensor_col: list
   :param fmin: The lower bound of the frequency band
   :type fmin: int
   :param fmax: The upper bound of the frequency band
   :type fmax: int
   :param sampling_frequency: The sampling frequency of the signal (default: 100)
   :type sampling_frequency: int
   :param window_type: The type of window to be used for the FFT (default: 'hann')
   :type window_type: str

   :returns: The power in the specified frequency band
   :rtype: float


.. py:function:: compute_perc_power(sensor_col: list, fmin_band: int, fmax_band: int, fmin_total: int = 0, fmax_total: int = 100, sampling_frequency: int = 100, window_type: str = 'hann') -> float

   Note: sensor_col is a single cell (which corresponds to a single window) of sensor_col, as it is used with apply function.

   Computes the percentage of power in a specific frequency band for a specified sensor and axis.

   :param sensor_col: The sensor column to be transformed (e.g. x-axis of accelerometer). This corresponds to a single window, which is a single row of the dataframe
   :type sensor_col: list
   :param fmin_band: The lower bound of the frequency band
   :type fmin_band: int
   :param fmax_band: The upper bound of the frequency band
   :type fmax_band: int
   :param fmin_total: The lower bound of the frequency spectrum (default: 0)
   :type fmin_total: int
   :param fmax_total: The upper bound of the frequency spectrum (default: 100)
   :type fmax_total: int
   :param sampling_frequency: The sampling frequency of the signal (default: 100)
   :type sampling_frequency: int
   :param window_type: The type of window to be used for the FFT (default: 'hann')
   :type window_type: str

   :returns: The percentage of power in the specified frequency band
   :rtype: float


.. py:function:: get_dominant_frequency(signal_ffts: list, signal_freqs: list, fmin: int, fmax: int) -> float

   Note: signal_ffts and signal_freqs are single cells (which corresponds to a single window) of signal_ffts and signal_freqs, as it is used with apply function.

   Computes the dominant frequency in a specific frequency band.

   :param signal_ffts: The FFT values of the signal of a single window
   :type signal_ffts: list
   :param signal_freqs: The corresponding frequencies of the FFT values
   :type signal_freqs: list
   :param fmin: The lower bound of the frequency band
   :type fmin: int
   :param fmax: The upper bound of the frequency band
   :type fmax: int

   :returns: The dominant frequency in the specified frequency band
   :rtype: float


.. py:function:: compute_power(df: pandas.DataFrame, fft_cols: list) -> pandas.Series

   Compute the power of the FFT values.

   :param df: The dataframe containing the FFT values
   :type df: pd.DataFrame
   :param fft_cols: The names of the columns containing the FFT values
   :type fft_cols: list

   :returns: The power of the FFT values
   :rtype: pd.Series


.. py:function:: generate_cepstral_coefficients(total_power_col: pandas.Series, window_length_s: int, sampling_frequency: int = 100, low_frequency: int = 0, high_frequency: int = 25, n_filters: int = 20, n_coefficients: int = 12) -> pandas.DataFrame

   Generate cepstral coefficients from the total power of the signal.

   :param total_power_col: The total power of the signal, extracted using compute_power
   :type total_power_col: pd.Series
   :param window_length_s: The number of seconds a window constitutes
   :type window_length_s: int
   :param sampling_frequency: The sampling frequency of the data (default: 100)
   :type sampling_frequency: int
   :param low_frequency: The lower bound of the frequency band (default: 0)
   :type low_frequency: int
   :param high_frequency: The upper bound of the frequency band (default: 25)
   :type high_frequency: int
   :param n_filters: The number of DCT filters (default: 20)
   :type n_filters: int
   :param n_coefficients: The number of coefficients to extract (default: 12)
   :type n_coefficients: int

   :returns: A dataframe with a single column corresponding to a single cepstral coefficient
   :rtype: pd.DataFrame


.. py:function:: pca_transform_gyroscope(df: pandas.DataFrame, y_gyro_colname: str, z_gyro_colname: str, pred_gait_colname: str) -> pandas.Series

   Apply principal component analysis (PCA) on the y-axis and z-axis of the raw gyroscope signal
   to extract the velocity. PCA is applied to the predicted gait timestamps only to maximize the similarity
   to the velocity in the arm swing direction.

   :param df: The dataframe containing the gyroscope data
   :type df: pd.DataFrame
   :param y_gyro_colname: The column name of the y-axis of the gyroscope
   :type y_gyro_colname: str
   :param z_gyro_colname: The column name of the z-axis of the gyroscope
   :type z_gyro_colname: str
   :param pred_gait_colname: The column name of the predicted gait boolean
   :type pred_gait_colname: str

   :returns: The first principal component corresponding to the angular velocity in the arm swing direction
   :rtype: pd.Series


.. py:function:: compute_angle(velocity_col: pandas.Series, time_col: pandas.Series) -> pandas.Series

   Apply cumulative trapezoidal integration to extract the angle from the velocity.

   :param velocity_col: The angular velocity (gyroscope) column to be integrated
   :type velocity_col: pd.Series
   :param time_col: The time column corresponding to the angular velocity
   :type time_col: pd.Series

   :returns: An estimation of the angle extracted from the angular velocity
   :rtype: pd.Series


.. py:function:: remove_moving_average_angle(angle_col: pandas.Series, sampling_frequency: int = 100) -> pandas.Series

   Remove the moving average from the angle to account for potential drift in the signal.

   :param angle_col: The angle column to be processed, obtained using compute_angle
   :type angle_col: pd.Series
   :param sampling_frequency: The sampling frequency of the data (default: 100)
   :type sampling_frequency: int

   :returns: The estimated angle without potential drift
   :rtype: pd.Series


.. py:function:: extract_angle_extremes(df: pandas.DataFrame, angle_colname: str, dominant_frequency_colname: str, sampling_frequency: int = 100) -> pandas.Series

   Extract the peaks of the angle (minima and maxima) from the smoothed angle signal that adhere to a set of specific requirements.

   :param df: The dataframe containing the angle signal
   :type df: pd.DataFrame
   :param angle_colname: The name of the column containing the smoothed angle signal
   :type angle_colname: str
   :param dominant_frequency_colname: The name of the column containing the dominant frequency
   :type dominant_frequency_colname: str
   :param sampling_frequency: The sampling frequency of the data (default: 100)
   :type sampling_frequency: int

   :returns: The extracted angle extremes (peaks)
   :rtype: pd.Series


.. py:function:: extract_range_of_motion(angle_extrema_values_col: pandas.Series) -> pandas.Series

   Extract the range of motion from the angle extrema values.

   :param angle_extrema_values_col: The column containing the angle extrema values
   :type angle_extrema_values_col: pd.Series

   :returns: The range of motion
   :rtype: pd.Series


.. py:function:: extract_peak_angular_velocity(df: pandas.DataFrame, velocity_colname: str, angle_minima_colname: str, angle_maxima_colname: str) -> pandas.DataFrame

   Extract the forward and backward peak angular velocity from the angular velocity.

   :param df: The dataframe containing the angular velocity
   :type df: pd.DataFrame
   :param velocity_colname: The column name of the angular velocity
   :type velocity_colname: str
   :param angle_minima_colname: The column name of the column containing the angle minima
   :type angle_minima_colname: str
   :param angle_maxima_colname: The column name of the column containing the angle maxima
   :type angle_maxima_colname: str

   :returns: The dataframe with the forward and backward peak angular velocity
   :rtype: pd.DataFrame


.. py:function:: aggregate_segments(df: pandas.DataFrame, time_colname: str, segment_nr_colname: str, window_step_size_s: float, l_metrics: list, l_aggregates: list, l_quantiles: list = []) -> pandas.DataFrame

   Extract arm swing aggregations from segments of a dataframe

   :param df: Dataframe containing windowed arm swing features
   :type df: pd.DataFrame
   :param time_colname: Name of the column containing the start time of the window
   :type time_colname: str
   :param segment_nr_colname: Name of the column containing the segment number
   :type segment_nr_colname: str
   :param window_step_size_s: Duration of each window in seconds
   :type window_step_size_s: float
   :param l_metrics: List of metrics to aggregate
   :type l_metrics: list
   :param l_aggregates: List of aggregation functions to apply to the metrics
   :type l_aggregates: list
   :param l_quantiles: List of quantiles to calculate
   :type l_quantiles: list

   :returns: Dataframe of segments containing aggregated arm swing features for each segment
   :rtype: pd.DataFrame


.. py:function:: create_window(df: pandas.DataFrame, time_column_name: str, window_nr: int, lower_index: int, upper_index: int, data_point_level_cols: list, segment_nr: int, sampling_frequency: int = 100) -> list

   Transforms (a subset of) a dataframe into a single row

   :param df: The original dataframe to be windowed
   :type df: pd.DataFrame
   :param time_column_name: The name of the time column
   :type time_column_name: str
   :param window_nr: The identification of the window
   :type window_nr: int
   :param lower_index: The dataframe index of the first sample to be windowed
   :type lower_index: int
   :param upper_index: The dataframe index of the final sample to be windowed
   :type upper_index: int
   :param data_point_level_cols: The columns in sensor_df that are to be kept as individual datapoints in a list instead of aggregates
   :type data_point_level_cols: list
   :param segment_nr: The identification of the segment
   :type segment_nr: int
   :param sampling_frequency: The sampling frequency (Hz) of the data (default: 100)
   :type sampling_frequency: int, optional

   :returns: Rows corresponding to single windows
   :rtype: list


.. py:function:: tabulate_windows(df: pandas.DataFrame, time_column_name: str, data_point_level_cols: list, window_length_s: int = 6, window_step_size_s: int = 1, sampling_frequency: int = 100, segment_nr_colname: str = None, segment_nr: int = None) -> pandas.DataFrame

   Compiles multiple windows into a single dataframe

   :param df: The original dataframe to be windowed
   :type df: pd.DataFrame
   :param time_column_name: The name of the time column
   :type time_column_name: str
   :param data_point_level_cols: The names of the columns that are to be kept as individual datapoints in a list instead of aggregates
   :type data_point_level_cols: list
   :param window_length_s: The number of seconds a window constitutes (default: 6)
   :type window_length_s: int, optional
   :param window_step_size_s: The number of seconds between the end of the previous and the start of the next window (default: 1)
   :type window_step_size_s: int, optional
   :param sampling_frequency: The sampling frequency of the data (default: 100)
   :type sampling_frequency: int, optional
   :param segment_nr_colname: The name of the column that identifies the segment; set to None if not applicable (default: None)
   :type segment_nr_colname: str, optional
   :param segment_nr: The identification of the segment; set to None if not applicable (default: None)
   :type segment_nr: int, optional

   :returns: Dataframe with each row corresponding to an individual window
   :rtype: pd.DataFrame


.. py:function:: create_segments(df: pandas.DataFrame, time_colname: str, segment_nr_colname: str, minimum_gap_s: int) -> pandas.DataFrame

   Create segments based on the time column of the dataframe. Segments are defined as continuous time periods.

   :param df: The dataframe to be segmented
   :type df: pd.DataFrame
   :param time_colname: The name of the time column
   :type time_colname: str
   :param minimum_gap_s: The minimum gap in seconds to split up the time periods into segments
   :type minimum_gap_s: int

   :returns: The dataframe with additional columns related to segments
   :rtype: pd.DataFrame


.. py:function:: discard_segments(df: pandas.DataFrame, time_colname: str, segment_nr_colname: str, minimum_segment_length_s: int) -> pandas.DataFrame

   Discard segments that are shorter than a specified length.

   :param df: The dataframe containing information about the segments
   :type df: pd.DataFrame
   :param time_colname: The column name of the time column
   :type time_colname: str
   :param segment_nr_colname: The column name of the column containing the segment numbers
   :type segment_nr_colname: str
   :param minimum_segment_length_s: The minimum required length of a segment in seconds
   :type minimum_segment_length_s: int

   :returns: The dataframe with segments that are longer than the specified length
   :rtype: pd.DataFrame


.. py:function:: get_end_iso8601(start_iso8601, window_length_seconds)

.. py:function:: write_data(metadata_time: tsdf.TSDFMetadata, metadata_samples: tsdf.TSDFMetadata, output_path: str, output_filename: str, df: pandas.DataFrame)

.. py:function:: read_metadata(input_path: str, meta_filename: str, time_filename: str, values_filename: str) -> Tuple[tsdf.TSDFMetadata, tsdf.TSDFMetadata]

.. py:function:: extract_temporal_domain_features(config, df_windowed, l_gravity_stats=['mean', 'std'])

.. py:function:: extract_spectral_domain_features(config, df_windowed, sensor, l_sensor_colnames)

.. py:function:: extract_gait_features(input_path: str, output_path: str, config: paradigma.gait_analysis_config.GaitFeatureExtractionConfig) -> None

.. py:function:: detect_gait(input_path: str, output_path: str, path_to_classifier_input: str, config: paradigma.gait_analysis_config.GaitDetectionConfig) -> None

.. py:function:: extract_arm_swing_features(input_path: str, output_path: str, config: paradigma.gait_analysis_config.ArmSwingFeatureExtractionConfig) -> None

.. py:function:: detect_arm_swing(input_path: str, output_path: str, path_to_classifier_input: str, config: paradigma.gait_analysis_config.ArmSwingDetectionConfig) -> None

.. py:function:: quantify_arm_swing(path_to_feature_input: str, path_to_prediction_input: str, output_path: str, config: paradigma.gait_analysis_config.ArmSwingQuantificationConfig) -> None

.. py:function:: aggregate_weekly_arm_swing()

